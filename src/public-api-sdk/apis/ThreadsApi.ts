/* tslint:disable */
/* eslint-disable */
/**
 * Narmi Public API
 * To read about Public API access and authentication, go to [API Overview](https://docs.narmi.com/docs/narmi-developer-docs/xl9dvbz84o11l-introduction).
 *
 * The version of the OpenAPI document: v1
 * Contact: support@narmi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AccountsDocumentsRetrieve404Response,
  InvalidRequestError,
  MessageCreateRequest,
  MessageCreateResponse,
  MessageResponse,
  MessagesResponse,
  NotFoundError,
  ThreadCreateRequest,
  ThreadResponse,
  ThreadUpdateRequest,
  ThreadUploadPolicyCreateDocRequest,
  ThreadUploadPolicyResponse,
  ThreadsResponse,
  UploadFileError,
} from '../models/index';
import {
    AccountsDocumentsRetrieve404ResponseFromJSON,
    AccountsDocumentsRetrieve404ResponseToJSON,
    InvalidRequestErrorFromJSON,
    InvalidRequestErrorToJSON,
    MessageCreateRequestFromJSON,
    MessageCreateRequestToJSON,
    MessageCreateResponseFromJSON,
    MessageCreateResponseToJSON,
    MessageResponseFromJSON,
    MessageResponseToJSON,
    MessagesResponseFromJSON,
    MessagesResponseToJSON,
    NotFoundErrorFromJSON,
    NotFoundErrorToJSON,
    ThreadCreateRequestFromJSON,
    ThreadCreateRequestToJSON,
    ThreadResponseFromJSON,
    ThreadResponseToJSON,
    ThreadUpdateRequestFromJSON,
    ThreadUpdateRequestToJSON,
    ThreadUploadPolicyCreateDocRequestFromJSON,
    ThreadUploadPolicyCreateDocRequestToJSON,
    ThreadUploadPolicyResponseFromJSON,
    ThreadUploadPolicyResponseToJSON,
    ThreadsResponseFromJSON,
    ThreadsResponseToJSON,
    UploadFileErrorFromJSON,
    UploadFileErrorToJSON,
} from '../models/index';

export interface ThreadFilesPoliciesCreateRequest {
    threadUploadPolicyCreateDocRequest: ThreadUploadPolicyCreateDocRequest;
    format?: ThreadFilesPoliciesCreateFormatEnum;
}

export interface ThreadsCreateRequest {
    threadCreateRequest: ThreadCreateRequest;
    format?: ThreadsCreateFormatEnum;
}

export interface ThreadsMarkReadUpdateRequest {
    uuid: string;
    format?: ThreadsMarkReadUpdateFormatEnum;
}

export interface ThreadsRetrieveRequest {
    endDate?: Date;
    filter?: string;
    format?: ThreadsRetrieveFormatEnum;
    orderBy?: ThreadsRetrieveOrderByEnum;
    startDate?: Date;
}

export interface UserMessagesCreateRequest {
    threadUuids: string;
    format?: UserMessagesCreateFormatEnum;
    messageCreateRequest?: MessageCreateRequest;
}

export interface UserMessagesListRequest {
    threadUuids: string;
    format?: UserMessagesListFormatEnum;
}

export interface UserMessagesRetrieveRequest {
    threadUuid: string;
    uuid: string;
    format?: UserMessagesRetrieveFormatEnum;
}

export interface UserThreadsRetrieveRequest {
    uuid: string;
    format?: UserThreadsRetrieveFormatEnum;
}

export interface UserThreadsUpdateRequest {
    uuid: string;
    format?: UserThreadsUpdateFormatEnum;
    threadUpdateRequest?: ThreadUpdateRequest;
}

/**
 * 
 */
export class ThreadsApi extends runtime.BaseAPI {

    /**
     * Creates the payload for a signed request to upload a file directly to S3. Further documentation can be found via the AWS documentation: https://aws.amazon.com/blogs/compute/uploading-to-amazon-s3-directly-from-a-web-or-mobile-application/
     * Create a signed request for uploading a file to S3
     */
    async threadFilesPoliciesCreateRaw(requestParameters: ThreadFilesPoliciesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ThreadUploadPolicyResponse>> {
        if (requestParameters['threadUploadPolicyCreateDocRequest'] == null) {
            throw new runtime.RequiredError(
                'threadUploadPolicyCreateDocRequest',
                'Required parameter "threadUploadPolicyCreateDocRequest" was null or undefined when calling threadFilesPoliciesCreate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/thread_files/policies/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ThreadUploadPolicyCreateDocRequestToJSON(requestParameters['threadUploadPolicyCreateDocRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ThreadUploadPolicyResponseFromJSON(jsonValue));
    }

    /**
     * Creates the payload for a signed request to upload a file directly to S3. Further documentation can be found via the AWS documentation: https://aws.amazon.com/blogs/compute/uploading-to-amazon-s3-directly-from-a-web-or-mobile-application/
     * Create a signed request for uploading a file to S3
     */
    async threadFilesPoliciesCreate(requestParameters: ThreadFilesPoliciesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ThreadUploadPolicyResponse> {
        const response = await this.threadFilesPoliciesCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a support message thread for the authenticated user.
     * Create message thread for a user
     */
    async threadsCreateRaw(requestParameters: ThreadsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ThreadResponse>> {
        if (requestParameters['threadCreateRequest'] == null) {
            throw new runtime.RequiredError(
                'threadCreateRequest',
                'Required parameter "threadCreateRequest" was null or undefined when calling threadsCreate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/threads/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ThreadCreateRequestToJSON(requestParameters['threadCreateRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ThreadResponseFromJSON(jsonValue));
    }

    /**
     * Create a support message thread for the authenticated user.
     * Create message thread for a user
     */
    async threadsCreate(requestParameters: ThreadsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ThreadResponse> {
        const response = await this.threadsCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mark the specified support message thread as read.
     * Modify thread mark read
     */
    async threadsMarkReadUpdateRaw(requestParameters: ThreadsMarkReadUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling threadsMarkReadUpdate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/threads/{uuid}/mark_read/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Mark the specified support message thread as read.
     * Modify thread mark read
     */
    async threadsMarkReadUpdate(requestParameters: ThreadsMarkReadUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.threadsMarkReadUpdateRaw(requestParameters, initOverrides);
    }

    /**
     * List support message threads for the authenticated user.
     * List user\'s message threads
     */
    async threadsRetrieveRaw(requestParameters: ThreadsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ThreadsResponse>> {
        const queryParameters: any = {};

        if (requestParameters['endDate'] != null) {
            queryParameters['end_date'] = (requestParameters['endDate'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['orderBy'] != null) {
            queryParameters['order_by'] = requestParameters['orderBy'];
        }

        if (requestParameters['startDate'] != null) {
            queryParameters['start_date'] = (requestParameters['startDate'] as any).toISOString().substring(0,10);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/threads/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ThreadsResponseFromJSON(jsonValue));
    }

    /**
     * List support message threads for the authenticated user.
     * List user\'s message threads
     */
    async threadsRetrieve(requestParameters: ThreadsRetrieveRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ThreadsResponse> {
        const response = await this.threadsRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a message on the specified support message thread as the authenticated user.   Define either `body` or `url` in the request to create a message or attachment, respectively.
     * Create a message in a thread
     */
    async userMessagesCreateRaw(requestParameters: UserMessagesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageCreateResponse>> {
        if (requestParameters['threadUuids'] == null) {
            throw new runtime.RequiredError(
                'threadUuids',
                'Required parameter "threadUuids" was null or undefined when calling userMessagesCreate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/threads/{thread_uuids}/messages/`.replace(`{${"thread_uuids"}}`, encodeURIComponent(String(requestParameters['threadUuids']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MessageCreateRequestToJSON(requestParameters['messageCreateRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MessageCreateResponseFromJSON(jsonValue));
    }

    /**
     * Create a message on the specified support message thread as the authenticated user.   Define either `body` or `url` in the request to create a message or attachment, respectively.
     * Create a message in a thread
     */
    async userMessagesCreate(requestParameters: UserMessagesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageCreateResponse> {
        const response = await this.userMessagesCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List messages for the specified support message threads. The threads are specified in the path parameters as comma-separated UUIDs. If the thread does not exist, this endpoint will return a 404. Response will include both messages and thread files (i.e. attachments).
     * List messages in a thread
     */
    async userMessagesListRaw(requestParameters: UserMessagesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessagesResponse>> {
        if (requestParameters['threadUuids'] == null) {
            throw new runtime.RequiredError(
                'threadUuids',
                'Required parameter "threadUuids" was null or undefined when calling userMessagesList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/threads/{thread_uuids}/messages/`.replace(`{${"thread_uuids"}}`, encodeURIComponent(String(requestParameters['threadUuids']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MessagesResponseFromJSON(jsonValue));
    }

    /**
     * List messages for the specified support message threads. The threads are specified in the path parameters as comma-separated UUIDs. If the thread does not exist, this endpoint will return a 404. Response will include both messages and thread files (i.e. attachments).
     * List messages in a thread
     */
    async userMessagesList(requestParameters: UserMessagesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessagesResponse> {
        const response = await this.userMessagesListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch a specified message on the specified support message thread. This request will not return thread files (i.e. attachments).
     * Retrieve user messages
     */
    async userMessagesRetrieveRaw(requestParameters: UserMessagesRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageResponse>> {
        if (requestParameters['threadUuid'] == null) {
            throw new runtime.RequiredError(
                'threadUuid',
                'Required parameter "threadUuid" was null or undefined when calling userMessagesRetrieve().'
            );
        }

        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling userMessagesRetrieve().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/threads/{thread_uuid}/messages/{uuid}/`.replace(`{${"thread_uuid"}}`, encodeURIComponent(String(requestParameters['threadUuid']))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MessageResponseFromJSON(jsonValue));
    }

    /**
     * Fetch a specified message on the specified support message thread. This request will not return thread files (i.e. attachments).
     * Retrieve user messages
     */
    async userMessagesRetrieve(requestParameters: UserMessagesRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageResponse> {
        const response = await this.userMessagesRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch a specified support message thread.
     * Retrieve a thread
     */
    async userThreadsRetrieveRaw(requestParameters: UserThreadsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ThreadResponse>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling userThreadsRetrieve().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/threads/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ThreadResponseFromJSON(jsonValue));
    }

    /**
     * Fetch a specified support message thread.
     * Retrieve a thread
     */
    async userThreadsRetrieve(requestParameters: UserThreadsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ThreadResponse> {
        const response = await this.userThreadsRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mark a specified support message thread as closed or open.
     * Update user\'s thread
     */
    async userThreadsUpdateRaw(requestParameters: UserThreadsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ThreadResponse>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling userThreadsUpdate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/threads/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ThreadUpdateRequestToJSON(requestParameters['threadUpdateRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ThreadResponseFromJSON(jsonValue));
    }

    /**
     * Mark a specified support message thread as closed or open.
     * Update user\'s thread
     */
    async userThreadsUpdate(requestParameters: UserThreadsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ThreadResponse> {
        const response = await this.userThreadsUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ThreadFilesPoliciesCreateFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type ThreadFilesPoliciesCreateFormatEnum = typeof ThreadFilesPoliciesCreateFormatEnum[keyof typeof ThreadFilesPoliciesCreateFormatEnum];
/**
 * @export
 */
export const ThreadsCreateFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type ThreadsCreateFormatEnum = typeof ThreadsCreateFormatEnum[keyof typeof ThreadsCreateFormatEnum];
/**
 * @export
 */
export const ThreadsMarkReadUpdateFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type ThreadsMarkReadUpdateFormatEnum = typeof ThreadsMarkReadUpdateFormatEnum[keyof typeof ThreadsMarkReadUpdateFormatEnum];
/**
 * @export
 */
export const ThreadsRetrieveFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type ThreadsRetrieveFormatEnum = typeof ThreadsRetrieveFormatEnum[keyof typeof ThreadsRetrieveFormatEnum];
/**
 * @export
 */
export const ThreadsRetrieveOrderByEnum = {
    CreatedAt: 'created_at',
    UpdatedAt: 'updated_at'
} as const;
export type ThreadsRetrieveOrderByEnum = typeof ThreadsRetrieveOrderByEnum[keyof typeof ThreadsRetrieveOrderByEnum];
/**
 * @export
 */
export const UserMessagesCreateFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type UserMessagesCreateFormatEnum = typeof UserMessagesCreateFormatEnum[keyof typeof UserMessagesCreateFormatEnum];
/**
 * @export
 */
export const UserMessagesListFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type UserMessagesListFormatEnum = typeof UserMessagesListFormatEnum[keyof typeof UserMessagesListFormatEnum];
/**
 * @export
 */
export const UserMessagesRetrieveFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type UserMessagesRetrieveFormatEnum = typeof UserMessagesRetrieveFormatEnum[keyof typeof UserMessagesRetrieveFormatEnum];
/**
 * @export
 */
export const UserThreadsRetrieveFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type UserThreadsRetrieveFormatEnum = typeof UserThreadsRetrieveFormatEnum[keyof typeof UserThreadsRetrieveFormatEnum];
/**
 * @export
 */
export const UserThreadsUpdateFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type UserThreadsUpdateFormatEnum = typeof UserThreadsUpdateFormatEnum[keyof typeof UserThreadsUpdateFormatEnum];
