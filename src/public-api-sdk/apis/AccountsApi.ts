/* tslint:disable */
/* eslint-disable */
/**
 * Narmi Public API
 * To read about Public API access and authentication, go to [API Overview](https://docs.narmi.com/docs/narmi-developer-docs/xl9dvbz84o11l-introduction).
 *
 * The version of the OpenAPI document: v1
 * Contact: support@narmi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AccountStopResponse,
  AccountVerify,
  AccountWithdrawal,
  AccountsNotFoundError,
  DocumentResponse,
  ExternalAccountCreate,
  ExternalAccountVerification,
  GeneralError,
  HoldsListResponse,
  InvalidRequestError,
  NestedAccount,
  NestedAccounts,
  NotFoundError,
  PaginatedAccountStopsResponse,
  PaginatedAccounts,
  PatchedAccountStop,
  PermissionDeniedError,
  ServiceFailureError,
  Success,
  TransactionsResponse,
  UpdateAccount,
} from '../models/index';
import {
    AccountStopResponseFromJSON,
    AccountStopResponseToJSON,
    AccountVerifyFromJSON,
    AccountVerifyToJSON,
    AccountWithdrawalFromJSON,
    AccountWithdrawalToJSON,
    AccountsNotFoundErrorFromJSON,
    AccountsNotFoundErrorToJSON,
    DocumentResponseFromJSON,
    DocumentResponseToJSON,
    ExternalAccountCreateFromJSON,
    ExternalAccountCreateToJSON,
    ExternalAccountVerificationFromJSON,
    ExternalAccountVerificationToJSON,
    GeneralErrorFromJSON,
    GeneralErrorToJSON,
    HoldsListResponseFromJSON,
    HoldsListResponseToJSON,
    InvalidRequestErrorFromJSON,
    InvalidRequestErrorToJSON,
    NestedAccountFromJSON,
    NestedAccountToJSON,
    NestedAccountsFromJSON,
    NestedAccountsToJSON,
    NotFoundErrorFromJSON,
    NotFoundErrorToJSON,
    PaginatedAccountStopsResponseFromJSON,
    PaginatedAccountStopsResponseToJSON,
    PaginatedAccountsFromJSON,
    PaginatedAccountsToJSON,
    PatchedAccountStopFromJSON,
    PatchedAccountStopToJSON,
    PermissionDeniedErrorFromJSON,
    PermissionDeniedErrorToJSON,
    ServiceFailureErrorFromJSON,
    ServiceFailureErrorToJSON,
    SuccessFromJSON,
    SuccessToJSON,
    TransactionsResponseFromJSON,
    TransactionsResponseToJSON,
    UpdateAccountFromJSON,
    UpdateAccountToJSON,
} from '../models/index';

export interface AccountVerifyRequest {
    uuid: string;
    format?: AccountVerifyFormatEnum;
    externalAccountVerification?: ExternalAccountVerification;
}

export interface AccountVerifyInstantRequest {
    format?: AccountVerifyInstantFormatEnum;
    externalAccountVerification?: ExternalAccountVerification;
}

export interface AccountsCreateRequest {
    externalAccountCreate: ExternalAccountCreate;
    format?: AccountsCreateFormatEnum;
}

export interface AccountsDestroyRequest {
    uuid: string;
    format?: AccountsDestroyFormatEnum;
}

export interface AccountsDocumentsRetrieveRequest {
    accountUuid: string;
    documentId: string;
    data?: boolean;
    format?: AccountsDocumentsRetrieveFormatEnum;
}

export interface AccountsHoldsRetrieveRequest {
    accountUuid: string;
    format?: AccountsHoldsRetrieveFormatEnum;
}

export interface AccountsListRequest {
    format?: AccountsListFormatEnum;
}

export interface AccountsRetrieveRequest {
    uuid: string;
    format?: AccountsRetrieveFormatEnum;
}

export interface AccountsStopsCreateRequest {
    accountUuid: string;
    format?: AccountsStopsCreateFormatEnum;
    patchedAccountStop?: Omit<PatchedAccountStop, 'account_id'>;
}

export interface AccountsStopsRetrieveRequest {
    accountUuid: string;
    format?: AccountsStopsRetrieveFormatEnum;
}

export interface AccountsTransactionsDownloadRetrieveRequest {
    accountUuid: string;
    fileFormat?: AccountsTransactionsDownloadRetrieveFileFormatEnum;
    format?: AccountsTransactionsDownloadRetrieveFormatEnum;
    maxDate?: Date;
    minDate?: Date;
    period?: AccountsTransactionsDownloadRetrievePeriodEnum;
}

export interface AccountsUpdateRequest {
    uuid: string;
    format?: AccountsUpdateFormatEnum;
    updateAccount?: UpdateAccount;
}

export interface AccountsWithdrawalsCreateRequest {
    uuid: string;
    accountWithdrawal: AccountWithdrawal;
    format?: AccountsWithdrawalsCreateFormatEnum;
}

export interface UserTransactionsListRequest {
    accountUuids: string;
    after?: string;
    before?: string;
    block?: boolean;
    filter?: UserTransactionsListFilterEnum;
    format?: UserTransactionsListFormatEnum;
    page?: number;
    q?: string;
}

/**
 * 
 */
export class AccountsApi extends runtime.BaseAPI {

    /**
     * Verify the micro-deposit amounts for a specified external account. Additional information on micro-deposits/micro-entries and how they work can be found here https://www.nacha.org/micro-entries.  In the event that the account does not exist or cannot be associated with the user, or ACH is not enabled, the endpoint will return a 404.  In the event that the user does not have permission to modify the account, the endpoint will return a 403.
     * Run account verification
     */
    async accountVerifyRaw(requestParameters: AccountVerifyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountVerify>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling accountVerify().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/accounts/{uuid}/verify/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExternalAccountVerificationToJSON(requestParameters['externalAccountVerification']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountVerifyFromJSON(jsonValue));
    }

    /**
     * Verify the micro-deposit amounts for a specified external account. Additional information on micro-deposits/micro-entries and how they work can be found here https://www.nacha.org/micro-entries.  In the event that the account does not exist or cannot be associated with the user, or ACH is not enabled, the endpoint will return a 404.  In the event that the user does not have permission to modify the account, the endpoint will return a 403.
     * Run account verification
     */
    async accountVerify(requestParameters: AccountVerifyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountVerify> {
        const response = await this.accountVerifyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Instant verification for accounts that have been linked through MX. The FI must have features `ach` and `instant_account_verification` enabled. If ACH is not enabled the endpoint will return a 404. If `instant_account_verification` is not enabled, the endpoint will return a 422 detailing the issue. In the event that there is an issue running verification, the endpoint will return a 500.
     * Run instant account verification
     */
    async accountVerifyInstantRaw(requestParameters: AccountVerifyInstantRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NestedAccount>> {
        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/accounts/verify/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExternalAccountVerificationToJSON(requestParameters['externalAccountVerification']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NestedAccountFromJSON(jsonValue));
    }

    /**
     * Instant verification for accounts that have been linked through MX. The FI must have features `ach` and `instant_account_verification` enabled. If ACH is not enabled the endpoint will return a 404. If `instant_account_verification` is not enabled, the endpoint will return a 422 detailing the issue. In the event that there is an issue running verification, the endpoint will return a 500.
     * Run instant account verification
     */
    async accountVerifyInstant(requestParameters: AccountVerifyInstantRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NestedAccount> {
        const response = await this.accountVerifyInstantRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a reference to an external account. Returns a list of accounts that will always be length 1.
     * Create external account
     */
    async accountsCreateRaw(requestParameters: AccountsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NestedAccounts>> {
        if (requestParameters['externalAccountCreate'] == null) {
            throw new runtime.RequiredError(
                'externalAccountCreate',
                'Required parameter "externalAccountCreate" was null or undefined when calling accountsCreate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/accounts/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExternalAccountCreateToJSON(requestParameters['externalAccountCreate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NestedAccountsFromJSON(jsonValue));
    }

    /**
     * Create a reference to an external account. Returns a list of accounts that will always be length 1.
     * Create external account
     */
    async accountsCreate(requestParameters: AccountsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NestedAccounts> {
        const response = await this.accountsCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove the logged-in user from a specified account. The account must be external, users cannot unlink themselves from internal accounts.
     * Remove user from an account
     */
    async accountsDestroyRaw(requestParameters: AccountsDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling accountsDestroy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/accounts/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove the logged-in user from a specified account. The account must be external, users cannot unlink themselves from internal accounts.
     * Remove user from an account
     */
    async accountsDestroy(requestParameters: AccountsDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.accountsDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * Fetch a specific statement by statement ID.   An invalid document ID will typically return the documented error response, however if the `statements` feature is not enabled, it may also return a blank 404 response.  This endpoint will return a 404 if a trailing slash is included in the request.
     * Retrieve a document
     */
    async accountsDocumentsRetrieveRaw(requestParameters: AccountsDocumentsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentResponse>> {
        if (requestParameters['accountUuid'] == null) {
            throw new runtime.RequiredError(
                'accountUuid',
                'Required parameter "accountUuid" was null or undefined when calling accountsDocumentsRetrieve().'
            );
        }

        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling accountsDocumentsRetrieve().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['data'] != null) {
            queryParameters['data'] = requestParameters['data'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/accounts/{account_uuid}/documents/{document_id}/`.replace(`{${"account_uuid"}}`, encodeURIComponent(String(requestParameters['accountUuid']))).replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentResponseFromJSON(jsonValue));
    }

    /**
     * Fetch a specific statement by statement ID.   An invalid document ID will typically return the documented error response, however if the `statements` feature is not enabled, it may also return a blank 404 response.  This endpoint will return a 404 if a trailing slash is included in the request.
     * Retrieve a document
     */
    async accountsDocumentsRetrieve(requestParameters: AccountsDocumentsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentResponse> {
        const response = await this.accountsDocumentsRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List the holds for an authenticated user\'s account specified by UUID, excluding expired holds.Will return 404 if the account specified does not exist. Will return 500 error if there are any issues connecting to the core.
     * List holds for account
     */
    async accountsHoldsRetrieveRaw(requestParameters: AccountsHoldsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HoldsListResponse>> {
        if (requestParameters['accountUuid'] == null) {
            throw new runtime.RequiredError(
                'accountUuid',
                'Required parameter "accountUuid" was null or undefined when calling accountsHoldsRetrieve().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/accounts/{account_uuid}/holds/`.replace(`{${"account_uuid"}}`, encodeURIComponent(String(requestParameters['accountUuid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HoldsListResponseFromJSON(jsonValue));
    }

    /**
     * List the holds for an authenticated user\'s account specified by UUID, excluding expired holds.Will return 404 if the account specified does not exist. Will return 500 error if there are any issues connecting to the core.
     * List holds for account
     */
    async accountsHoldsRetrieve(requestParameters: AccountsHoldsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HoldsListResponse> {
        const response = await this.accountsHoldsRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List the authenticated user\'s accounts. The account data will update from the core when this endpoint is requested if the oldest account has not been updated in over `Core Minimum Update Seconds`. The response contains both internal and external account types.
     * List accounts
     */
    async accountsListRaw(requestParameters: AccountsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedAccounts>> {
        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/accounts/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedAccountsFromJSON(jsonValue));
    }

    /**
     * List the authenticated user\'s accounts. The account data will update from the core when this endpoint is requested if the oldest account has not been updated in over `Core Minimum Update Seconds`. The response contains both internal and external account types.
     * List accounts
     */
    async accountsList(requestParameters: AccountsListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedAccounts> {
        const response = await this.accountsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch a specified account. Both external and internal accounts can be listed using this call. Account information is not updated from the core, and is fetched from the database.
     * Retrieve an account
     */
    async accountsRetrieveRaw(requestParameters: AccountsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NestedAccount>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling accountsRetrieve().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/accounts/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NestedAccountFromJSON(jsonValue));
    }

    /**
     * Fetch a specified account. Both external and internal accounts can be listed using this call. Account information is not updated from the core, and is fetched from the database.
     * Retrieve an account
     */
    async accountsRetrieve(requestParameters: AccountsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NestedAccount> {
        const response = await this.accountsRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a stop payment for a specified account. This endpoint will return a 404 if the account does not exist or if the stop feature is not enabled for the institution. Some cores will support the ability to specify a stop payment range (`min_check_number`->`max_check_number`) but in the event that it is not supported, the endpoint will also return a 404. If the core is inactive the endpoint will return a 500, and if there is an issue creating the stop on the core, the endpoint will return a 503.
     * Create a stop payment
     */
    async accountsStopsCreateRaw(requestParameters: AccountsStopsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountStopResponse>> {
        if (requestParameters['accountUuid'] == null) {
            throw new runtime.RequiredError(
                'accountUuid',
                'Required parameter "accountUuid" was null or undefined when calling accountsStopsCreate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/accounts/{account_uuid}/stops/`.replace(`{${"account_uuid"}}`, encodeURIComponent(String(requestParameters['accountUuid']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedAccountStopToJSON(requestParameters['patchedAccountStop']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountStopResponseFromJSON(jsonValue));
    }

    /**
     * Create a stop payment for a specified account. This endpoint will return a 404 if the account does not exist or if the stop feature is not enabled for the institution. Some cores will support the ability to specify a stop payment range (`min_check_number`->`max_check_number`) but in the event that it is not supported, the endpoint will also return a 404. If the core is inactive the endpoint will return a 500, and if there is an issue creating the stop on the core, the endpoint will return a 503.
     * Create a stop payment
     */
    async accountsStopsCreate(requestParameters: AccountsStopsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountStopResponse> {
        const response = await this.accountsStopsCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List stop payments for a specified account. Pagination for this response is used only as a placeholder for future implementation and will not return metadata or pagination links.
     * List stop payments
     */
    async accountsStopsRetrieveRaw(requestParameters: AccountsStopsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedAccountStopsResponse>> {
        if (requestParameters['accountUuid'] == null) {
            throw new runtime.RequiredError(
                'accountUuid',
                'Required parameter "accountUuid" was null or undefined when calling accountsStopsRetrieve().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/accounts/{account_uuid}/stops/`.replace(`{${"account_uuid"}}`, encodeURIComponent(String(requestParameters['accountUuid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedAccountStopsResponseFromJSON(jsonValue));
    }

    /**
     * List stop payments for a specified account. Pagination for this response is used only as a placeholder for future implementation and will not return metadata or pagination links.
     * List stop payments
     */
    async accountsStopsRetrieve(requestParameters: AccountsStopsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedAccountStopsResponse> {
        const response = await this.accountsStopsRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export transaction history to a file.  Custom date range can be defined by specifying the `period` parameter as `custom`.  Some validation errors (e.g. when specifying a min date which is greater than a max date) may result in malformatted error responses.  Please note that the response headers do not indicate the proper response content type.
     * Get transactions download
     */
    async accountsTransactionsDownloadRetrieveRaw(requestParameters: AccountsTransactionsDownloadRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['accountUuid'] == null) {
            throw new runtime.RequiredError(
                'accountUuid',
                'Required parameter "accountUuid" was null or undefined when calling accountsTransactionsDownloadRetrieve().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fileFormat'] != null) {
            queryParameters['file_format'] = requestParameters['fileFormat'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['maxDate'] != null) {
            queryParameters['max_date'] = (requestParameters['maxDate'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['minDate'] != null) {
            queryParameters['min_date'] = (requestParameters['minDate'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['period'] != null) {
            queryParameters['period'] = requestParameters['period'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/accounts/{account_uuid}/transactions_download/`.replace(`{${"account_uuid"}}`, encodeURIComponent(String(requestParameters['accountUuid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Export transaction history to a file.  Custom date range can be defined by specifying the `period` parameter as `custom`.  Some validation errors (e.g. when specifying a min date which is greater than a max date) may result in malformatted error responses.  Please note that the response headers do not indicate the proper response content type.
     * Get transactions download
     */
    async accountsTransactionsDownloadRetrieve(requestParameters: AccountsTransactionsDownloadRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.accountsTransactionsDownloadRetrieveRaw(requestParameters, initOverrides);
    }

    /**
     * Update fields for a specified account. This endpoint performs a partial, non-idempotent update, so any fields can be included or omitted. Any missing or additional fields will be ignored.
     * Update an account
     */
    async accountsUpdateRaw(requestParameters: AccountsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NestedAccount>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling accountsUpdate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/accounts/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateAccountToJSON(requestParameters['updateAccount']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NestedAccountFromJSON(jsonValue));
    }

    /**
     * Update fields for a specified account. This endpoint performs a partial, non-idempotent update, so any fields can be included or omitted. Any missing or additional fields will be ignored.
     * Update an account
     */
    async accountsUpdate(requestParameters: AccountsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NestedAccount> {
        const response = await this.accountsUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a withdrawal for an account specified by UUID.
     * Create account withdrawal
     */
    async accountsWithdrawalsCreateRaw(requestParameters: AccountsWithdrawalsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Success>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling accountsWithdrawalsCreate().'
            );
        }

        if (requestParameters['accountWithdrawal'] == null) {
            throw new runtime.RequiredError(
                'accountWithdrawal',
                'Required parameter "accountWithdrawal" was null or undefined when calling accountsWithdrawalsCreate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/accounts/{uuid}/withdrawals/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccountWithdrawalToJSON(requestParameters['accountWithdrawal']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessFromJSON(jsonValue));
    }

    /**
     * Create a withdrawal for an account specified by UUID.
     * Create account withdrawal
     */
    async accountsWithdrawalsCreate(requestParameters: AccountsWithdrawalsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Success> {
        const response = await this.accountsWithdrawalsCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List transactions for the authenticated user. Transactions are collated from accounts which the user is a member of.<br /><br />If queried via the <a href=\"#tag/accounts/operation/user_transactions_list\">/v1/accounts/{account_uuids}/transactions</a> endpoint, the call will return a 404 if all the comma-separated list of `account_uuids` are non-existent.<br /><br />Pagination can be defined either via the `before` and `after` query parameters for cursor pagination or via the `page` parameter for page number pagination. Both styles of pagination accept a `per_page` parameter, which indicates how many results should be returned.
     * List user transactions
     */
    async userTransactionsListRaw(requestParameters: UserTransactionsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionsResponse>> {
        if (requestParameters['accountUuids'] == null) {
            throw new runtime.RequiredError(
                'accountUuids',
                'Required parameter "accountUuids" was null or undefined when calling userTransactionsList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['after'] != null) {
            queryParameters['after'] = requestParameters['after'];
        }

        if (requestParameters['before'] != null) {
            queryParameters['before'] = requestParameters['before'];
        }

        if (requestParameters['block'] != null) {
            queryParameters['block'] = requestParameters['block'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("OAuth2", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/accounts/{account_uuids}/transactions/`.replace(`{${"account_uuids"}}`, encodeURIComponent(String(requestParameters['accountUuids']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionsResponseFromJSON(jsonValue));
    }

    /**
     * List transactions for the authenticated user. Transactions are collated from accounts which the user is a member of.<br /><br />If queried via the <a href=\"#tag/accounts/operation/user_transactions_list\">/v1/accounts/{account_uuids}/transactions</a> endpoint, the call will return a 404 if all the comma-separated list of `account_uuids` are non-existent.<br /><br />Pagination can be defined either via the `before` and `after` query parameters for cursor pagination or via the `page` parameter for page number pagination. Both styles of pagination accept a `per_page` parameter, which indicates how many results should be returned.
     * List user transactions
     */
    async userTransactionsList(requestParameters: UserTransactionsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionsResponse> {
        const response = await this.userTransactionsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const AccountVerifyFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type AccountVerifyFormatEnum = typeof AccountVerifyFormatEnum[keyof typeof AccountVerifyFormatEnum];
/**
 * @export
 */
export const AccountVerifyInstantFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type AccountVerifyInstantFormatEnum = typeof AccountVerifyInstantFormatEnum[keyof typeof AccountVerifyInstantFormatEnum];
/**
 * @export
 */
export const AccountsCreateFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type AccountsCreateFormatEnum = typeof AccountsCreateFormatEnum[keyof typeof AccountsCreateFormatEnum];
/**
 * @export
 */
export const AccountsDestroyFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type AccountsDestroyFormatEnum = typeof AccountsDestroyFormatEnum[keyof typeof AccountsDestroyFormatEnum];
/**
 * @export
 */
export const AccountsDocumentsRetrieveFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type AccountsDocumentsRetrieveFormatEnum = typeof AccountsDocumentsRetrieveFormatEnum[keyof typeof AccountsDocumentsRetrieveFormatEnum];
/**
 * @export
 */
export const AccountsHoldsRetrieveFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type AccountsHoldsRetrieveFormatEnum = typeof AccountsHoldsRetrieveFormatEnum[keyof typeof AccountsHoldsRetrieveFormatEnum];
/**
 * @export
 */
export const AccountsListFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type AccountsListFormatEnum = typeof AccountsListFormatEnum[keyof typeof AccountsListFormatEnum];
/**
 * @export
 */
export const AccountsRetrieveFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type AccountsRetrieveFormatEnum = typeof AccountsRetrieveFormatEnum[keyof typeof AccountsRetrieveFormatEnum];
/**
 * @export
 */
export const AccountsStopsCreateFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type AccountsStopsCreateFormatEnum = typeof AccountsStopsCreateFormatEnum[keyof typeof AccountsStopsCreateFormatEnum];
/**
 * @export
 */
export const AccountsStopsRetrieveFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type AccountsStopsRetrieveFormatEnum = typeof AccountsStopsRetrieveFormatEnum[keyof typeof AccountsStopsRetrieveFormatEnum];
/**
 * @export
 */
export const AccountsTransactionsDownloadRetrieveFileFormatEnum = {
    Csv: 'csv',
    Ofx: 'ofx',
    Qbo: 'qbo',
    Qfx: 'qfx',
    Qif: 'qif'
} as const;
export type AccountsTransactionsDownloadRetrieveFileFormatEnum = typeof AccountsTransactionsDownloadRetrieveFileFormatEnum[keyof typeof AccountsTransactionsDownloadRetrieveFileFormatEnum];
/**
 * @export
 */
export const AccountsTransactionsDownloadRetrieveFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type AccountsTransactionsDownloadRetrieveFormatEnum = typeof AccountsTransactionsDownloadRetrieveFormatEnum[keyof typeof AccountsTransactionsDownloadRetrieveFormatEnum];
/**
 * @export
 */
export const AccountsTransactionsDownloadRetrievePeriodEnum = {
    CurrentMonth: 'current_month',
    CurrentYear: 'current_year',
    Custom: 'custom',
    Month: 'month',
    PreviousMonth: 'previous_month',
    PreviousYear: 'previous_year',
    Year: 'year'
} as const;
export type AccountsTransactionsDownloadRetrievePeriodEnum = typeof AccountsTransactionsDownloadRetrievePeriodEnum[keyof typeof AccountsTransactionsDownloadRetrievePeriodEnum];
/**
 * @export
 */
export const AccountsUpdateFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type AccountsUpdateFormatEnum = typeof AccountsUpdateFormatEnum[keyof typeof AccountsUpdateFormatEnum];
/**
 * @export
 */
export const AccountsWithdrawalsCreateFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type AccountsWithdrawalsCreateFormatEnum = typeof AccountsWithdrawalsCreateFormatEnum[keyof typeof AccountsWithdrawalsCreateFormatEnum];
/**
 * @export
 */
export const UserTransactionsListFilterEnum = {
    Hidden: 'hidden',
    Unsettled: 'unsettled'
} as const;
export type UserTransactionsListFilterEnum = typeof UserTransactionsListFilterEnum[keyof typeof UserTransactionsListFilterEnum];
/**
 * @export
 */
export const UserTransactionsListFormatEnum = {
    Html: 'html',
    Json: 'json'
} as const;
export type UserTransactionsListFormatEnum = typeof UserTransactionsListFormatEnum[keyof typeof UserTransactionsListFormatEnum];
